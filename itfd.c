
#include "itfd.h"


void* itfd_print(void *str) {
    syslog(LOG_INFO, "received string from client: %s\n", (char *)str);

    return NULL;
}


int main(void) {
    struct sockaddr_un addr;
    char buf[100];
    int fd, cl, rc;

    /* Our process ID and Session ID */
    pid_t pid, sid;

    /* Fork off the parent process */
    pid = fork();
    if (pid < 0) {
        exit(EXIT_FAILURE);
    }

    /* If we got a good PID, then we can exit the parent process. */
    if (pid > 0) {
        exit(EXIT_SUCCESS);
    }

    char *socket_path = "\0hidden";

    // Create an new socket for communicating with client
    if((fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
        perror("socket error");
        exit(-1);
    }

    memset(&addr, 0, sizeof(addr));
    addr.sun_family = AF_UNIX;
    strncpy(addr.sun_path, socket_path, sizeof(addr.sun_path) - 1);

    unlink(socket_path);

    // Bind address to socket
    if(bind(fd, (struct sockaddr *)&addr, sizeof(addr)) == -1) {
        perror("bind error");
        exit(-1);
    }

    // Listen the socket
    if(listen(fd, 5) == -1) {
        perror("listen error");
        exit(-1);
    }


    /* Change the file mode mask */
    /* By setting the umask to 0, we will have full access to the files generated by the daemon. */
    umask(0);

    /* Open any logs here */
    /* This part is optional, but it is recommended that you open a log file somewhere in the system
       for writing. This may be the only place you can look for debug information about your daemon.*/
    openlog ("firstdaemon", LOG_PID, LOG_DAEMON);

    /* Create a new SID for the child process */
    sid = setsid();
    if (sid < 0) {
        /* Log the failure */
        exit(EXIT_FAILURE);
    }

    /* Change the current working directory */
    if ((chdir("/")) < 0) {
        /* Log the failure */
        exit(EXIT_FAILURE);
    }

    /* Close out the standard file descriptors */
    close(STDIN_FILENO);
    close(STDOUT_FILENO);
    close(STDERR_FILENO);

    /* Daemon-specific initialization goes here */

    /* initialize thread pool, we need to destroy thread pool when we exit program. */
    pool_init(5);

    syslog(LOG_NOTICE, "Listening Start");
    /* The Big Loop */
    while (1) {
        /* Do some task here ... */

        // syslog(LOG_NOTICE, "First daemon started.");
        // sleep(20); /* wait 20 seconds */
        // syslog(LOG_NOTICE, "First daemon started.");
        //
        int done, recvbytes;

        syslog(LOG_INFO, "Waiting for a connection...\n");
        if((cl = accept(fd, NULL, NULL)) == -1) {
            perror("accept error");
            continue;
        }

        syslog(LOG_INFO, "Connected.\n");
        done = 0;
        do {

            // Receive data from client
            recvbytes = recv(cl, buf, sizeof(buf), 0);
            if(recvbytes <= 0) {
                if(recvbytes < 0)
                    perror("recv");
                done = 1;
            }

            buf[recvbytes] = '\0';
            //syslog(LOG_INFO, "%s\n", buf);

            if(strncmp(buf, "create", 6) == 0) {
                pool_add_job(itfd_print, buf);
            }
            else if(strncmp(buf, "quit", 4) == 0) {
                break;
            }

            if(!done) {
                if(send(cl, "I've received.", sizeof("I've received."), 0) < 0) {
                    perror("send");
                    done = 1;
                }
            }
        }while(!done);

        close(cl);

        /* quit daemon */
        if(strncmp(buf, "quit", 4) == 0) {
            break;
        }
    }

    /* Destroy thread pool */
    pool_destroy();
    syslog(LOG_NOTICE, "Destroy thread pool");

    /* Terminate the current process */
    syslog(LOG_NOTICE, "First daemon terminated.");
    closelog();

    exit(EXIT_SUCCESS);

}

